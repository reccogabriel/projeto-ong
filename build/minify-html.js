#!/usr/bin/env node

/**
 * MINIFY-HTML.JS - Minifica√ß√£o de arquivos HTML
 * 
 * Usa html-minifier-terser para otimizar HTML:
 * - Remove espa√ßos em branco desnecess√°rios
 * - Remove coment√°rios
 * - Minifica CSS inline
 * - Minifica JavaScript inline
 * - Remove atributos redundantes
 */

const fs = require('fs-extra');
const path = require('path');
const { minify } = require('html-minifier-terser');

// Configura√ß√£o
const srcDir = path.join(__dirname, '..');
const distDir = path.join(__dirname, '..', 'dist');

// Op√ß√µes de minifica√ß√£o
const minifyOptions = {
  collapseBooleanAttributes: true,
  collapseWhitespace: true,
  conservativeCollapse: false,
  decodeEntities: true,
  html5: true,
  includeAutoGeneratedTags: false,
  keepClosingSlash: false,
  minifyCSS: true,
  minifyJS: true,
  minifyURLs: true,
  preserveLineBreaks: false,
  preventAttributesEscaping: false,
  processConditionalComments: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeEmptyAttributes: true,
  removeEmptyElements: false,
  removeOptionalTags: false,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  removeTagWhitespace: true,
  sortAttributes: true,
  sortClassName: true,
  useShortDoctype: true
};

/**
 * Minificar arquivo HTML
 */
async function minifyHtmlFile(filePath) {
  try {
    const relativePath = path.relative(srcDir, filePath);
    const content = await fs.readFile(filePath, 'utf8');
    
    // Minificar
    const minified = await minify(content, minifyOptions);
    
    // Salvar
    const outputPath = path.join(distDir, relativePath);
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, minified, 'utf8');
    
    // Estat√≠sticas
    const originalSize = Buffer.byteLength(content, 'utf8');
    const minifiedSize = Buffer.byteLength(minified, 'utf8');
    const reduction = ((originalSize - minifiedSize) / originalSize * 100).toFixed(1);
    
    console.log(`  ‚úì ${relativePath} (${reduction}% menor)`);
    
    return { originalSize, minifiedSize };
  } catch (error) {
    console.error(`  ‚úó Erro ao minificar ${filePath}:`, error.message);
    throw error;
  }
}

/**
 * Buscar arquivos HTML
 */
async function findHtmlFiles(dir) {
  const files = [];
  const items = await fs.readdir(dir);
  
  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = await fs.stat(fullPath);
    
    if (stat.isDirectory()) {
      // Ignorar certas pastas
      if (!['node_modules', 'build', 'dist', '.git', '.github'].includes(item)) {
        const subFiles = await findHtmlFiles(fullPath);
        files.push(...subFiles);
      }
    } else if (path.extname(item) === '.html') {
      files.push(fullPath);
    }
  }
  
  return files;
}

/**
 * Main
 */
async function main() {
  try {
    console.log('\nüìÑ Minificando HTML...\n');
    
    // Encontrar arquivos HTML
    const htmlFiles = await findHtmlFiles(srcDir);
    
    if (htmlFiles.length === 0) {
      console.log('  ‚ö† Nenhum arquivo HTML encontrado\n');
      return;
    }
    
    console.log(`  Encontrados ${htmlFiles.length} arquivo(s) HTML\n`);
    
    // Minificar cada arquivo
    let totalOriginal = 0;
    let totalMinified = 0;
    
    for (const file of htmlFiles) {
      const { originalSize, minifiedSize } = await minifyHtmlFile(file);
      totalOriginal += originalSize;
      totalMinified += minifiedSize;
    }
    
    // Resumo
    const totalReduction = ((totalOriginal - totalMinified) / totalOriginal * 100).toFixed(1);
    console.log(`\n  Total: ${totalReduction}% de redu√ß√£o\n`);
    
  } catch (error) {
    console.error('\n‚úó Erro na minifica√ß√£o de HTML:', error.message);
    process.exit(1);
  }
}

// Executar apenas se chamado diretamente
if (require.main === module) {
  main();
}

module.exports = { minifyHtmlFile, findHtmlFiles };
